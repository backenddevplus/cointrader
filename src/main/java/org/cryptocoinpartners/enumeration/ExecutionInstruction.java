// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: TypeSafeEnumeration.vsl in andromda-java-cartridge.
// Model Class: Data::AlgoTrader::com.algoTrader::enumeration::Status
// Metafacade: org.andromda.metafacades.uml.Enumeration
// Stereotype: Enumeration
//
package org.cryptocoinpartners.enumeration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * 
 */
public enum ExecutionInstruction {

    /** Order add current order to book */
    MAKER("MAKER"),
    /** Order takes current order of book */
    TAKER("TAKER");

    private final String enumValue;

    /**
     * The constructor with enumeration literal value allowing
     * super classes to access it.
     */
    private ExecutionInstruction(String value) {
        this.enumValue = value;
    }

    /**
     * Retrieves an instance of Status from <code>its name</code>.
     *
     * @param name the name to create the Status from.
     * @return The enumeration literal named after the 'name' argument
     */
    public static ExecutionInstruction fromString(String name) {
        return ExecutionInstruction.valueOf(name);
    }

    /**
     * Returns an enumeration literal String <code>value</code>.
     * Required by JAXB2 enumeration implementation
     *
     * @return String with corresponding value
     */
    public String value() {
        return this.enumValue;
    }

    /**
     * Returns an instance of Status from String <code>value</code>.
     * Required by JAXB2 enumeration implementation
     *
     * @param value the value to create the Status from.
     * @return static Enumeration with corresponding value
     */
    public static ExecutionInstruction fromValue(String value) {
        for (ExecutionInstruction enumName : ExecutionInstruction.values()) {
            if (enumName.getValue().equals(value)) {
                return enumName;
            }
        }
        throw new IllegalArgumentException("Status.fromValue(" + value + ')');
    }

    /**
     * Gets the underlying value of this type safe enumeration.
     * This method is necessary to comply with DaoBase implementation.
     * @return The name of this literal.
     */
    public String getValue() {
        return this.enumValue;
    }

    /**
     * Returns an unmodifiable list containing the literals that are known by this enumeration.
     *
     * @return A List containing the actual literals defined by this enumeration, this list
     *         can not be modified.
     */
    public static List<String> literals() {
        return ExecutionInstruction.literals;
    }

    /**
     * Returns an unmodifiable list containing the names of the literals that are known
     * by this enumeration.
     *
     * @return A List containing the actual names of the literals defined by this
     *         enumeration, this list can not be modified.
     */
    public static List<String> names() {
        return ExecutionInstruction.names;
    }

    private static Map<String, ExecutionInstruction> values = new LinkedHashMap<String, ExecutionInstruction>(7, 1);
    private static List<String> literals = new ArrayList<String>(7);
    private static List<String> names = new ArrayList<String>(7);
    private static List<ExecutionInstruction> valueList = new ArrayList<ExecutionInstruction>(7);

    /**
     * Initializes the values.
     */
    static {
        synchronized (ExecutionInstruction.values) {
            ExecutionInstruction.values.put(MAKER.enumValue, MAKER);
            ExecutionInstruction.values.put(TAKER.enumValue, TAKER);

        }
        synchronized (ExecutionInstruction.valueList) {
            ExecutionInstruction.valueList.add(MAKER);
            ExecutionInstruction.valueList.add(TAKER);

            ExecutionInstruction.valueList = Collections.unmodifiableList(valueList);
        }
        synchronized (ExecutionInstruction.literals) {
            ExecutionInstruction.literals.add(MAKER.enumValue);
            ExecutionInstruction.literals.add(TAKER.enumValue);

            ExecutionInstruction.literals = Collections.unmodifiableList(literals);
        }
        synchronized (ExecutionInstruction.names) {
            ExecutionInstruction.names.add("MAKER");
            ExecutionInstruction.names.add("TAKER");

            ExecutionInstruction.names = Collections.unmodifiableList(names);
        }
    }
    // type-safe-enumeration-object java merge-point
}
